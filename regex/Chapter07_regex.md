# 用正则表达式查找文本模式
| 字符 | 含义 |
| ---- | ---- |
| \d | 表示一位数字字符 |
| () | 分组，一个括号括起来的正则表达式，就是一个组。（使用group([编号])获取那个组中的数据。如果想要获取全部组，使用groups()方法。） |
| \ | 转义字符‘\’用于转义下一个字符，使其不再具有特殊意义。例如：‘\.’匹配点而不是匹配任何字符。 |
| \| | ‘\|’称为管道符，用于表示“或”的关系。具体而言，`A\|B`表示匹配A或B |
| ？ | **零次或一次匹配（可选项）：** 在一个字符或一个括号表达式后面放置 `?`，表示该字符或表达式是可选的，即可以出现零次或一次。例如，`colou?r` 匹配 "color" 和 "colour"。 |
| {} | 如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括 号包围的数字。例如，正则表达式(Ha){3}将匹配字符串'HaHaHa'，但不会匹配'HaHa'，因为后者只重复了(Ha)分组两次。 |

## 利用括号分组
```python
import re

phoneNumRegex = re.compile(r'(\d{3})-(\d{3}-\d{4})')
mo = phoneNumRegex.search('My number is 415-555-4242.')

# 输出整个匹配的电话号码
print(mo.group())  # 输出 "415-555-4242"

# 输出第一个分组，即区号
print(mo.group(1))  # 输出 "415"

# 输出第二个分组，即剩余的号码部分
print(mo.group(2))  # 输出 "555-4242"

# 输出所有分组的元组
print(mo.groups())  # 输出 ('415', '555-4242')
'''
程序在Pycharm中运行的结果为:
------------------------
415-555-4242
415
555-4242
('415', '555-4242')
------------------------
总结:
在这个例子中，`mo.groups()` 返回的是一个包含所有分组匹配结果的元组。
'''
```
## 利用管道匹配多个分组
```python
import re

heroRegex = re.compile(r'Batman|Tina Fey')

# 在 'Batman and Tina Fey.' 中匹配到了 Batman
mo1 = heroRegex.search('Batman and Tina Fey.')
print(mo1.group())  # 输出 "Batman"

# 在 'Tina Fey and Batman.' 中匹配到了 Tina Fey
mo2 = heroRegex.search('Tina Fey and Batman.')
print(mo2.group())  # 输出 "Tina Fey"

'''
程序在Pycharm中运行的结果为:
------------------------
Batman
Tina Fey
------------------------
总结:
正则表达式中的 `|` 表示“或”的关系，即匹配其中一个模式。在这里，它匹配字符串中的 `Batman` 或 `Tina Fey`。
'''
```
## 利用问号实现可选匹配
```python
import re

phoneRegex = re.compile(r'(\d{3}-)?\d{3}-\d{4}')

# 在 'My number is 415-555-4242' 中匹配到了完整的电话号码
mo1 = phoneRegex.search('My number is 415-555-4242')
print(mo1.group())  # 输出 "415-555-4242"

# 在 'My number is 555-4242' 中匹配到了没有区号的电话号码
mo2 = phoneRegex.search('My number is 555-4242')
print(mo2.group())  # 输出 "555-4242"

'''
程序在Pycharm中运行的结果为:
------------------------
415-555-4242
555-4242
------------------------
总结:
正则表达式 `(\d{3}-)?` 表示一个可选的区号部分，其中 `(\d{3}-)` 匹配三个数字加一个短横线，`?` 表示前面的组可以出现 0 次或 1 次。这样就允许匹配带区号和不带区号的电话号码。
'''
```
## 利用星号匹配零次或多次
```python
batRegex = re.compile(r'Bat(wo)*man')  
mo1 = batRegex.search('The Adventures of Batman')  
print(mo1.group())  
  
mo2 = batRegex.search('The Adventures of Batwoman')  
print(mo2.group())  
  
mo3 = batRegex.search('The Adventures of Batwowoman')  
print(mo3.group())

'''
程序在Pycharm中运行的结果为:
------------------------
Batman
Batwoman
Batwowoman
------------------------
总结:
'''
```
## 利用花括号匹配特定次数
```python
# 编译了一个正则表达式模式，该模式匹配正好三个字符串’Ha’的出现。
haRegex = re.compile(r'(Ha){3}')  
# 在字符串’HaHaHa’中搜索该模式。由于这个字符串包含三个’Ha’，它应该匹配该模式。
mo1 = haRegex.search('HaHaHa')  
# 打印出与模式匹配的字符串部分，即’HaHaHa’。
print(mo1.group())  
# 在字符串’Ha’中搜索该模式。由于这个字符串只包含一个’Ha’，它不符合模式的要求。
mo2 = haRegex.search('Ha')  
# 打印出True，因为mo2是None，表示没有找到匹配。
print(mo2 == None)

'''
程序在Pycharm中运行的结果为:
------------------------
HaHaHa
True
------------------------
总结:
'''
```
# 贪心和非贪心匹配
### 贪心匹配（Greedy Match）：
- 贪心匹配会尝试匹配尽可能多的字符。
- 它会从字符串的起始位置开始，尽可能地扩展匹配的范围，直到达到量词的最大可能匹配次数或者遇到下一个正则表达式的部分为止。
- 例如，对于模式 a.*b 应用到字符串 aabab，贪心匹配会匹配整个字符串 aabab，因为它会尽可能多地匹配 .（任意字符）。
### 非贪心匹配（Non-Greedy Match）：
- 非贪心匹配会尝试匹配尽可能少的字符。
- 它会从字符串的起始位置开始，尽可能地减少匹配的范围，一旦满足量词的最小匹配次数就会停止。
- 在量词后面加上 ? 可以实现非贪心匹配，例如模式 a.*?b 应用到字符串 aabab，非贪心匹配会只匹配 aab，因为它会尽可能少地匹配 .（任意字符）。
## 利用贪心匹配和非贪心匹配
```python
import re  

# greedyHaRegex 模式 (Ha){3,5} 表示匹配 “Ha” 至少3次，最多5次。由于是贪婪模式，它会尽可能多地匹配，直到达到最大次数5次，所以输出是 HaHaHaHaHa。
greedyHaRegex = re.compile(r'(Ha){3,5}')  
mo1 = greedyHaRegex.search('HaHaHaHaHaHaHaHa')  
print(mo1.group())  

# nongreedyRegex 模式 (Ha){3,5}? 中的 ? 表示非贪婪模式。它会尽可能少地匹配，只要满足最小次数3次即可，所以输出是 HaHaHa。
nongreedyRegex = re.compile(r'(Ha){3,5}?')  
mo2 = nongreedyRegex.search('HaHaHaHaHaHaHaHa')  
print(mo2.group())

'''
程序在Pycharm中运行的结果为:
------------------------
HaHaHaHaHa
HaHaHa
------------------------
总结:
'''
```
# findall()方法
- findall()方法将返回一组 字符串，包含被查找字符串中的所有匹配。
- findall()不是返回一个 Match 对象，而是返回一个字符串列表
- 如果在正则表达式中有分组，那么findall 将返回元组的列表。每个元组表示一个找 到的匹配，其中的项就是正则表达式中每个分组的匹配字符串。
## findall方法返回结果的总结
1. 如果调用在一个没有分组的正则表达式上，例如\d\d\d-\d\d\d-\d\d\d\d，方法 findall()将返回一个匹配字符串的列表，例如['415-555-9999', '212-555-0000']。
```python
import re

phoneNumRegex = re.compile(r'\d{3}-\d{3}-\d{4}')  
mo1 = phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')  
print(mo1)

'''
程序在Pycharm中运行的结果为:
------------------------
['415-555-9999', '212-555-0000']
------------------------
总结:
'''
```
2. 如果调用在一个有分组的正则表达式上，例如(\d\d\d)-(\d\d\d)-(\d\d\d\d)，方法 findall()将返回一个字符串的元组的列表（每个分组对应一个字符串），例如[('415',
	'555', '1122'), ('212', '555', '0000')]。
```python
import re  
  
phoneNumRegex = re.compile(r'(\d{3})-(\d{3})-(\d{4})')  
mo1 = phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')  
print(mo1)

'''
程序在Pycharm中运行的结果为:
------------------------
[('415', '555', '9999'), ('212', '555', '0000')]
------------------------
总结:
'''
```
## 字符分类
| 字符  | 表示                           |
| --- | ---------------------------- |
| \d  | 0到9的任何数字                     |
| \D  | 除0到9的数字以外的任何字符               |
| \w  | 任何字母、数字或下划线字符（可以认为是匹配“单词”字符） |
| \W  | 除字母、数字和下划线以外的任何字符            |
| \s  | 空格、制表符或换行符（可以认为是匹配“空白”字符）    |
| \S  | 除空格、制表符和换行符以外的任何字符           |
| +   | 匹配一个或多个字符                    |
## 建立自己的字符分类

| 字符    | 含义                                                                                 |
| ----- | ---------------------------------------------------------------------------------- |
| []    | 方括号 [] 用于创建一个字符集，它匹配方括号内列出的任意一个字符。                                                 |
| 字符列表  | 例如：[xyz] 匹配"x"、"y"、"z"                                                             |
| 范围表示  | 例如：[a-z] 匹配任何小写字母                                                                  |
| 否定字符集 | 如果方括号内的第一个字符是 ^，则它表示一个否定字符集，匹配不在方括号内的任意一个字符。例如，[\^abc] 匹配除了 “a”、“b”、“c” 之外的任意一个字符。 |
| abc$  | 字符串必须从abc结束。                                                                       |
| \^abc | 字符串必须从spam开始                                                                       |
| ^abc$ | 精确匹配字符串 “abc”                                                                      |
## 通配字符

| 字符        | 含义                                               |
| --------- | ------------------------------------------------ |
| .         | 匹配除了换行之外的所有字符。字符只匹配一个字符                          |
| .*        | 句点字符表示“除换行外所有单个字符”，星号字符表示“前 面字符出现零次或多次”。（默认贪心模式） |
| re.DOTALL | 让点字符(.)匹配 '\n'                                   |
| re.I      | 不区分大小写                                           |

